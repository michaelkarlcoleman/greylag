GREYLAG TODO LIST						-*-outline-*-


==============================================================================

OVERALL GOALS

1.  Replace SEQUEST at SIMR with something at least as good.
2.  Do better than SEQUEST for things that SIMR cares about.
3.  Showcase Python w/C-ish inner loop code implementation strategy.
4.  Try to take the best ideas from other similar programs.
5.  Greylag as a pedagogical artifact and foundation for further
    experimentation.

==============================================================================


MILESTONE M1:

* Good first impression
* Basic correctness
* Handles at least LCQ input
* Nonspecific cleavage only?
* Generates SQT output, usable in our pipeline, at least for non-N15 runs
* Decent performance/efficiency on our clusters

MILESTONE M2:

* Basic public website/source release/git archive
* Documentation (asciidoc/man pages)



TASK QUEUE

* MINI-GOAL: Get something working that can be tested against MM/SEQUEST
* MINI-GOAL: basic greylag-process usable on our cluster (no mods)


* Mod/regime info in SQT output program (greylag-sqt)
** R lines to document mass regimes

  R	0	A	71.037114
  R	0	C	103.009184
  ...

  regime + fixed mods + pca mod + diff mod + terminal mod + isotope mods (N15 or
    natural)

1 for back compatibility, support ASDC*ASDF form, and maybe A1S2D1C3A1S2D1F4
       form
1 need a means to specify mapping preference?

** A lines for each M line to document regime (index of R) and residue mods

3 AR	0
4 APCA	+17.0
2 AM	12	+32.34	phosphorylation
3 AM	5	+57.0
4 AT	]	+18.0	name
4 AI	14	+1

** are these required?
  H       StaticMod       C=160.1388
  H       DiffMod TNA*=+2.0



** Try to keep back compatibility by grepping out A/R lines

* Why aren't scores a little more stable?

* update estimate factor

* Update docstrings

* Evaluate performance differences vs SEQUEST/MM/Xtandem?

* Design and implement greylag master process (work manifests?)

* Look for more dead code to remove

* Look at memory usage
** maybe avoid spectrum name copies
** maybe avoid locus name copies
** instead of copying db sequences, use Python's?

* Compare greylag/SEQUEST/MM on test-myrimatch example (non-specific)
** look at MM (whole file)
** Note: SEQUEST parent tolerance differs

* Basic optimization
** look at callgrind output

* Further test case updates/adds


= M1 =========================================================================



* do a cg-admin-rewritehist before publishing git archive?

= M2 =========================================================================

* Implement MM smart +3 model?
** Is it better?

* Try to generate a valid MyriMatch (bombs on boost random assertion)

* Try the MM precursor mass adjustment--much improvement?  even a good idea?

* Test tolerance monotonicity


* Examine DBValidate
** Design similar statistical evaluation
** Look at what we do here (paper)


* Add isotope jitter feature, for Orbitrap.

  xtandem considers one C13 if MH>1000, and one/two C13 if MH>1500.  Should we
  try to predict this based on the peptide sequence?  MH probably close
  enough.  What does MyriMatch do?


* Implement MyriMatch charge-calling algorithm?

* Implement MyriMatch deisotoping?


* Look more closely at specific MM vs GL match diffs.


* Figure out how to handle multiple residue mods (delta, isotope, etc)

* Clean up [,] (N/C-terminal) mass regime calculations

* Pass through the C++ code looking for counts that could conceivably overflow
** Fix or add assertions

* Add duplicate peptide masking optimization
** This will obviate the need to detect identical best matches at search time?
** Fix redundant peptide reporting


* Time a real mod search vs SEQUEST (and xtandem?), is time reasonable?
  MAKE SURE PARAMS ARE COMPARABLE!  Ballpark correctness?

* Create direct DTASelect.txt output?
  (This seems to be sufficient to support most or all DTASelect output.)

* Make a tool to compare greylag vs SEQUEST results by spectrum.  Want gross
  statistics--how many id's are the same, different, missing, etc.  For each
  spectrum, want to see what each program did, and how many times the assigned
  locus was otherwise id'ed.

* Investigate identification differences between greylag and SEQUEST.

* Careful timing and correctness check for
  /n/proteomics/mkc/HsProA-Control_S100_Ti_1_H_2006-03-03_wSHUFFLED-greylag

* Design and implement tracing of mass regime/PCA/fixed and non-fixed
  deltas/etc into output file.  Try to stay compatible with xtandem.

* PPM error tolerances (MyriMatch doesn't implement this?)

* Make --estimate work correctly over cluster.  (Currently takes 6 hours to
  estimate 60--is this worthwhile?  Could we simply estimate one bag and
  multiply by the number of bags??)

* Better shuffling than current model.

* Useful to scale fragment tolerance by charge, too?

* Have --estimate generate a spectrum work count file (*.est?) that can be
  used by --part-split to generate evenly sized parts.  (Check that file is
  newer than params file and ms2 file arguments, and that all ms2 file
  arguments were estimated.)

* Maybe --part-split should generate a downramp of sizes?  It definitely
  should take into account spectra filtered out (== no work), but this
  requires reading all spectra before splitting (which takes more time).

* Fix "cleavage C-terminal mass change" issue.  Should this be interpreted as
  MONO, ! (first fragment regime), or by regime.  Look for similar problems
  elsewhere.

* Make static '[' mod exclude PCA mods.

* Code cleanup, especially in new Python code.  Maybe put some stuff in
  classes.  Could split into multiple source files.

* Mine OMSSA and myrimatch for ideas.  Look again at X!Tandem and SEQUEST
  papers.

* Need tool to compare two runs, for regression testing purposes.

* Add refinement.  (like xtandem?)

* Advanced refinement ideas.  For example, only search a locus for a hit with N
  mods if we got a hit for it with 0..N-1 mods (or maybe 0..N-2?).  Or, only
  search a locus non-tryptically (or semi-tryptically) if we got a tryptic hit
  for it.

** Investigate current SEQUEST search results to see if this looks feasible.

* Think about ways to get more id's per hour of processing time.

* Try to adapt to instrument accuracy.  Maybe start with a narrow parent mass
  range and adaptively widen it.

* Profiling to find slow spots, and for correctness?

* Heavy optimization on inner loop.  Try running from both ends simultaneously.

* Should we try to guarantee that searching is equivalent for all mass regimes,
  to make comparisons more valid?

* Eval speedup: make intensity information integer, or otherwise store it in
  log form so we can add instead of multiplying?

* Try to switch FP code to use integers instead?

* Rigorously check all values coming in from Python (at least by assert).

* We can now pre-build a peptide index if we want to.  The main utility of this
  is that it would allow us to avoid searching a spectrum against the same
  peptide multiple times (saving perhaps 30% runtime for one real database).
  Alternatively, maybe we could just generate a description of peptides to be
  masked out.

* Look at moving C++ code to C+ctypes, or maybe pyrex?

* Incrementalize the whole program.  Want to be able to take an existing run
  and spend more time on it to get more results, possibly concentrating on a
  particular kind of modification.

* Try to figure out whether SEQUEST is really searching everything, or whether
  it gives up in certain cases like X!Tandem does.

* Isotope S34 and C13 are common (4%, 1%).  Is there a good way to look for
  them?  We could look for singleton occurrences pretty cheaply using a delta
  mod type procedure.

* Splitting idea: Rather than having all parts be equal, maybe its better for
  the parts processed first to be bigger, with smallest parts processed last,
  so that they can fill in the final gaps (leading all processors to finish at
  about the same time).  What should the split curve look like?  Linear, but
  what slope?  No split should be smaller than one spectrum (after
  filtering).

* Possible generation optimization: Figure out the maximum number of mods,
  which would be the number that could be added to the smallest, lightest
  peptide without exceeding the mass of the largest spectrum parent mass.
  Probably not worth doing?  Similarly, if we know all bags of size N are too
  large, and all deltas are positive, we can skip larger bags.

* Can we make the parts restartable?  If so, maybe this could be used to load
  balance, recover from crashes, etc.

* Is NOTHROW faster or slower?

* If we see a good hit for a spectrum, we could try to see if there's an
  identifiable tag.  If so, could restrict further searching to peptides with
  that tag.


TO FILE:

* What is this C+57 mod called?  Carboxyamidomethyl?  +C2H3ON!

* Is there anything we can do with neutral losses?

* test spectrum synthesis

* test semi-tryptic cleavage

* double-check handling of FP arithmetic using epsilons (no ==, no strict <)
